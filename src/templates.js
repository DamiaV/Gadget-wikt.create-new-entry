// <nowiki>
import pages from "./pages.js";

/**
 * @typedef {{
 *  title: string,
 *  notemplatedata: "",
 *  params: [] | Record<string, []>,
 * }} ApiNoTemplateData
 */

/**
 * @typedef {{
 *  title: string,
 *  name: string,
 *  description?: string,
 *  format?: string,
 *  params: Record<string, ApiTemplateParam>,
 *  paramOrder?: string[],
 *  sets?: TemplateSetObject[],
 * }} ApiTemplateData
 */

/**
 * @typedef {{
 *  label: string,
 *  description: string | null,
 *  required: boolean,
 *  suggested: boolean,
 *  deprecated: boolean | string,
 *  aliases: string[],
 *  default: string | null,
 *  autovalue: string | null,
 *  example: string | null,
 *  type: "unknown" | "number" | "string" | "line" | "boolean" | "date" | "url" | "wiki-page-name" | "wiki-file-name" | "wiki-template-name" | "wiki-user-name" | "content" | "unbalanced-wikitext",
 *  suggestedvalues: string[],
 * }} ApiTemplateParam
 */

/**
 * @typedef {{
 *  title: string,
 *  name: string,
 *  description?: string,
 *  format: string,
 *  params: Record<string, TemplateParam>,
 *  paramOrder: string[],
 *  sets: TemplateSetObject[],
 *  autoGenerated: boolean,
 * }} TemplateData
 */

/**
 * @typedef {{
 *  label: string,
 *  description?: string | null,
 *  required?: boolean,
 *  suggested?: boolean,
 *  deprecated?: boolean | string,
 *  aliases: string[],
 *  default?: string | null,
 *  autoValue?: string | number | boolean | null,
 *  example?: string | null,
 *  type: "unknown" | "number" | "string" | "line" | "boolean" | "date" | "url" | "wiki-page-name" | "wiki-file-name" | "wiki-template-name" | "wiki-user-name" | "content" | "unbalanced-wikitext",
 *  suggestedValues: (string | number)[],
 * }} TemplateParam
 */

/**
 * @typedef {{
 *  label: string,
 *  params: string[],
 * }} TemplateSetObject
 */

/**
 * @typedef {{
 *  name: string,
 *  format: TemplateFormat,
 *  paramOrder: string[],
 *  params: Record<string, any>,
 * }} FilledTemplate
 */

/**
 * @typedef {{
 *  newLineBeforeTemplate: boolean,
 *  newLineAfterTemplate: boolean,
 *  newLineBeforePipe: boolean,
 *  newLineAfterPipe: boolean,
 *  newLineBeforeClosing: boolean,
 *  spacesBeforePipe: number,
 *  spacesBeforeParamName: number,
 *  spacesBeforeEqual: number,
 *  spacesAfterEqual: number,
 *  minParamNameLength: number,
 * }} TemplateFormat
 */

/**
 * Convert a template object into its wikitext representation.
 * @param {FilledTemplate} filledTemplate The template object to convent to a string.
 * @returns {string} The wikitext for the template.
 */
function templateToString(filledTemplate) {
  const numberRegex = /^\d+$/;

  const paramOrder = filledTemplate.paramOrder;
  const params = Object.entries(filledTemplate.params);
  params.sort(
    ([name1], [name2]) => paramOrder.indexOf(name1) - paramOrder.indexOf(name2)
  );

  const format = filledTemplate.format;

  let template =
    (format.newLineBeforeTemplate ? "\n" : "") + "{{" + filledTemplate.name;

  /**
   * Format a named parameter.
   * @param {string} name The parameter name.
   * @param {any} value The parameter value.
   * @returns {string} The formatted name/value pair.
   */
  function formatNamedParam(name, value) {
    let stringifiedValue;
    if (typeof value === "string") stringifiedValue = value;
    else if (typeof value === "boolean") stringifiedValue = value ? "1" : "";
    else stringifiedValue = String(value);

    return (
      name.padEnd(format.minParamNameLength) +
      " ".repeat(format.spacesBeforeEqual) +
      "=" +
      " ".repeat(format.spacesAfterEqual) +
      stringifiedValue
    );
  }

  let lastPositionalParam = 0;
  for (const [name, value] of params) {
    if ([undefined, null, "", false].includes(value)) continue;

    template +=
      (format.newLineBeforePipe ? "\n" : "") +
      " ".repeat(format.spacesBeforePipe) +
      "|" +
      (format.newLineAfterPipe ? "\n" : "") +
      " ".repeat(format.spacesBeforeParamName);

    if (numberRegex.test(name)) {
      if (
        Number(name) - lastPositionalParam === 1 &&
        !String(value).includes("=")
      ) {
        template += String(value);
        lastPositionalParam++;
      } else {
        lastPositionalParam = -1; // Disable positional arguments
        template += formatNamedParam(name, value);
      }
    } else template += formatNamedParam(name, value);
  }

  return (
    template +
    (format.newLineBeforeClosing ? "\n" : "") +
    "}}" +
    (format.newLineAfterTemplate ? "\n" : "")
  );
}

/**
 * Parse a template format string into a TemplateFormat object.
 * @param {string} formatString The format string to parse.
 * @returns {TemplateFormat} The corresponding TemplateFormat object.
 * @throws If the format string is invalid.
 */
function parseTemplateFormat(formatString) {
  if (formatString === "inline") return parseTemplateFormat("{{_|_=_}}");
  if (formatString === "block") return parseTemplateFormat("{{_\n| _ = _\n}}");

  /**
   * @type {TemplateFormat}
   */
  const format = {
    newLineBeforeTemplate: false,
    newLineAfterTemplate: false,
    newLineBeforePipe: false,
    newLineAfterPipe: false,
    newLineBeforeClosing: false,
    spacesBeforePipe: 0,
    spacesBeforeParamName: 0,
    spacesBeforeEqual: 0,
    spacesAfterEqual: 0,
    minParamNameLength: 0,
  };

  /**
   * @param {number} i
   * @returns {never}
   */
  function throwError(i) {
    throw new Error(`Parse error at index ${i}: ${formatString}`);
  }

  let state = "before template";
  for (let i = 0; i < formatString.length; i++) {
    const c = formatString.charAt(i);
    const nextC = i < formatString.length - 1 ? formatString.charAt(i + 1) : "";

    switch (state) {
      case "before template":
        if (c === "\n") {
          if (format.newLineBeforeTemplate) throwError(i);
          format.newLineBeforeTemplate = true;
        } else if (c + nextC === "{{") {
          state = "after template opening";
          i++;
        } else throwError(i);
        break;

      case "after template opening":
        if (c === "_") state = "in template name";
        else throwError(i);
        break;

      case "in template name":
        if (c === "\n") {
          if (format.spacesBeforePipe !== 0 || format.newLineBeforePipe)
            throwError(i);
          format.newLineBeforePipe = true;
        } else if (c === " ") format.spacesBeforePipe++;
        else if (c === "|") state = "after pipe";
        else throwError(i);
        break;

      case "after pipe":
        if (c === "\n") {
          if (
            format.newLineBeforePipe ||
            format.spacesBeforeParamName !== 0 ||
            format.newLineAfterPipe
          )
            throwError(i);
          format.newLineAfterPipe = true;
        } else if (c === " ") format.spacesBeforeParamName++;
        else if (c === "_") {
          format.minParamNameLength++;
          state = "in arg name";
        } else throwError(i);
        break;

      case "in arg name":
        if (c === "_") format.minParamNameLength++;
        else if (c === " ") {
          format.spacesBeforeEqual++;
          state = "after arg name";
        } else if (c === "=") state = "after equal";
        else throwError(i);
        break;

      case "after arg name":
        if (c === " ") format.spacesBeforeEqual++;
        else if (c === "=") state = "after equal";
        else throwError(i);
        break;

      case "after equal":
        if (c === " ") format.spacesAfterEqual++;
        else if (c === "_") state = "after value";
        else throwError(i);
        break;

      case "after value":
        if (c === "\n") {
          if (format.newLineBeforeClosing) throwError(i);
          format.newLineBeforeClosing = true;
        } else if (c + nextC === "}}") {
          state = "after template";
          i++;
        } else throwError(i);
        break;

      case "after template":
        if (c === "\n") {
          if (format.newLineAfterTemplate) throwError(i);
          format.newLineAfterTemplate = true;
        } else throwError(i);
        break;
    }
  }

  return format;
}

/**
 * Search for templates matching the given search query or list of page titles or page IDs.
 * @param {string | string[] | number[]} query A query or list of page titles or page IDs.
 * @param {string} langCode The language code for the labels.
 * @param {mw.Api} api The MediaWiki API to use.
 * @returns {Promise<TemplateData[]>} A list of matching template’s data.
 */
async function searchTemplates(query, langCode, api) {
  const params = {
    action: "templatedata",
    includeMissingTitles: true,
    redirects: true,
    lang: langCode,
    format: "json",
  };
  if (typeof query === "string") {
    params.generator = "search";
    params.gsrsearch = pages.escapeQuery(query);
    params.gsrnamespace = 10;
    params.gsrlimit = 50;
    params.gsrprop = "redirecttitle";
  } else if (query.length && typeof query[0] === "number")
    params.pageids = query.join("|");
  else params.titles = query.join("|");

  /**
   * @type {{pages: Record<string, ApiTemplateData | ApiNoTemplateData>}}}
   */
  const json = await api.get(params);

  /**
   * @type {TemplateData[]}
   */
  const results = [];
  for (const templateData of Object.values(json.pages)) {
    if (
      templateData.title.includes("/Documentation") ||
      templateData.title.toLowerCase().includes("/bac à sable")
    )
      continue;

    const name = templateData.title.replace("Modèle:", "");
    if ("notemplatedata" in templateData) {
      /**
       * @type {Record<string, TemplateParam>}
       */
      const params = {};
      for (const name of Object.keys(templateData.params)) {
        params[name] = {
          label: name,
          aliases: [],
          type: "unknown",
          suggestedValues: [],
        };
      }
      results.push({
        title: templateData.title,
        name,
        format: "inline",
        params: params,
        paramOrder: Object.keys(params),
        sets: [],
        autoGenerated: true,
      });
    } else {
      /**
       * @type {Record<string, TemplateParam>}
       */
      const params = {};

      for (const [name, definition] of Object.entries(templateData.params)) {
        params[name] = {
          label: definition.label,
          description: definition.description,
          required: definition.required,
          suggested: definition.suggested,
          deprecated: definition.deprecated,
          aliases: definition.aliases,
          default: definition.default,
          autoValue: definition.autovalue,
          example: definition.example,
          type: definition.type,
          suggestedValues: definition.suggestedvalues.map((value) =>
            definition.type === "number" ? Number(value) : value
          ),
        };
      }

      results.push({
        title: templateData.title,
        name,
        description: templateData.description,
        format: templateData.format || "inline",
        params: params,
        paramOrder:
          templateData.paramOrder && templateData.paramOrder.length
            ? templateData.paramOrder
            : Object.keys(params),
        sets: templateData.sets || [],
        autoGenerated: false,
      });
    }
  }

  return results;
}

/**
 * Fetch the list of the current user’s favorite templates.
 * @param {mw.Api} api The MediaWiki API to use.
 * @returns {Promise<TemplateData[]>} An array containing the page IDs of each favorite template.
 */
async function fetchFavoriteTemplates(api) {
  /**
   * @type {{
   *  query: {
   *    userinfo: {
   *      options: {
   *        "templatedata-favorite-templates": string,
   *      }
   *    }
   *  }
   * }}
   */
  const json = await api.get({
    action: "query",
    meta: "userinfo",
    uiprop: "options",
    format: "json",
  });
  /**
   * @type {number[]}
   */
  const templateIDs = JSON.parse(
    json.query.userinfo.options["templatedata-favorite-templates"]
  );
  return await searchTemplates(templateIDs, "fr", api);
}

/**
 * Fetch the list of the wiki’s featured templates.
 * @param {mw.Api} api The MediaWiki API to use.
 * @returns {Promise<TemplateData[]>} An array containing the page IDs of each featured template.
 */
async function fetchFeaturedTemplates(api) {
  /**
   * @type {{
   *  communityconfiguration: {
   *    data: {
   *      FeaturedTemplates: {
   *        0: {
   *          titles: string[],
   *        }
   *      }
   *    }
   *  }
   * }}
   */
  const json = await api.get({
    action: "query",
    meta: "communityconfiguration",
    ccrprovider: "TemplateData-FeaturedTemplates",
    ccrassertversion: "1.0.0",
    formatversion: 2,
    format: "json",
  });
  return await searchTemplates(
    json.communityconfiguration.data.FeaturedTemplates[0].titles,
    "fr",
    api
  );
}

// </nowiki>
/**
 * This module defines types and functions related to wiki templates.
 *
 * [[Catégorie:JavaScript du Wiktionnaire|create-new-entry/templates.js]]
 */
export default {
  templateToString,
  parseTemplateFormat,
  searchTemplates,
  fetchFavoriteTemplates,
  fetchFeaturedTemplates,
};
